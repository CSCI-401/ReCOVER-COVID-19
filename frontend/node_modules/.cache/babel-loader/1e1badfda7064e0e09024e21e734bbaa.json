{"ast":null,"code":"import _objectSpread from\"/Users/tianjianxu/Documents/GitHub/ReCOVER-COVID-19/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _toConsumableArray from\"/Users/tianjianxu/Documents/GitHub/ReCOVER-COVID-19/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _slicedToArray from\"/Users/tianjianxu/Documents/GitHub/ReCOVER-COVID-19/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import _classCallCheck from\"/Users/tianjianxu/Documents/GitHub/ReCOVER-COVID-19/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"/Users/tianjianxu/Documents/GitHub/ReCOVER-COVID-19/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";import _inherits from\"/Users/tianjianxu/Documents/GitHub/ReCOVER-COVID-19/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";import _createSuper from\"/Users/tianjianxu/Documents/GitHub/ReCOVER-COVID-19/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";import React,{Component}from\"react\";import{ResponsiveLine}from\"@nivo/line\";import moment from\"moment\";import numeral from\"numeral\";import{red,gold,lime,cyan,geekblue,purple,magenta}from\"@ant-design/colors\";function getLineColor(index){var colors=[red.primary,gold.primary,lime.primary,cyan.primary,geekblue.primary,purple.primary,magenta.primary];return colors[index%colors.length];}// Custom layer for Nivo Line that allows us to display predictions as dashed\n// lines.\nvar DashedLine=function DashedLine(_ref){var series=_ref.series,lineGenerator=_ref.lineGenerator,xScale=_ref.xScale,yScale=_ref.yScale;return series.map(function(_ref2){var id=_ref2.id,data=_ref2.data,color=_ref2.color,predicted=_ref2.predicted,distancing=_ref2.distancing;var style={strokeWidth:3};// Add custom style if predicted.\nif(predicted){if(distancing){style.strokeDasharray=\"6, 4\";}else{// Display a sparser pattern for no social distancing.\nstyle.strokeDasharray=\"2, 6\";}}return/*#__PURE__*/React.createElement(\"path\",{key:id,d:lineGenerator(data.map(function(d){return{x:xScale(d.data.x),y:yScale(d.data.y)};})),fill:\"none\",stroke:color,style:style});});};var theme={axis:{ticks:{text:{fontSize:18}},legend:{text:{fontSize:18}}},legends:{text:{fontSize:18}}};var Covid19Graph=/*#__PURE__*/function(_Component){_inherits(Covid19Graph,_Component);var _super=_createSuper(Covid19Graph);function Covid19Graph(){_classCallCheck(this,Covid19Graph);return _super.apply(this,arguments);}_createClass(Covid19Graph,[{key:\"parseDate\",value:function parseDate(dateStr){var _dateStr$split$map=dateStr.split(\"-\").map(Number),_dateStr$split$map2=_slicedToArray(_dateStr$split$map,3),year=_dateStr$split$map2[0],month=_dateStr$split$map2[1],day=_dateStr$split$map2[2];// Month in JS is 0-based.\nmonth-=1;return new Date(year,month,day);}/**\n   * Given a time series returned by the predict endpoint, getCumulativeData\n   * returns it in Nivo format.\n   */},{key:\"getCumulativeData\",value:function getCumulativeData(data){var _this=this;return data.map(function(d){return{x:_this.parseDate(d.date),y:d.value};});}/**\n   * Given a time series returned by the predict endpoint, getDeltaData returns\n   * the adjacent difference of the timeseries, in Nivo format.\n   * @param initialVal - The initial value that is subtracted from the 1st\n   *  element.\n   */},{key:\"getDeltaData\",value:function getDeltaData(data,initialVal){var _this2=this;return data.map(function(d,i){if(i===0){return{x:_this2.parseDate(d.date),y:d.value-initialVal};}return{x:_this2.parseDate(d.date),y:d.value-data[i-1].value};});}// processData properly formats the given data, and performs special\n// operations based on parameter values.\n},{key:\"processData\",value:function processData(data,params){var statistic=params.statistic,yScale=params.yScale,initialVal=params.initialVal;// Determine whether we need to calculate deltas between points.\nvar retData=statistic===\"delta\"?this.getDeltaData(data,initialVal):this.getCumulativeData(data);// Remove all points with y = 0 if we're using log scale, otherwise it will\n// break.\nif(yScale===\"log\"){retData=retData.filter(function(_ref3){var x=_ref3.x,y=_ref3.y;return y>0;});}return retData;}/**\n   * getDataMax returns the maximum value present in the data supplied to the\n   * graph.\n   */},{key:\"getDataMax\",value:function getDataMax(){var data=this.props.data;var max=0;Object.keys(data).forEach(function(area){var _data$area=data[area],observed=_data$area.observed,predictions=_data$area.predictions;max=Math.max(max,Math.max.apply(Math,_toConsumableArray(observed.map(function(_ref4){var value=_ref4.value;return value;}))));predictions.forEach(function(p){var timeSeries=p.time_series;max=Math.max(max,Math.max.apply(Math,_toConsumableArray(timeSeries.map(function(_ref5){var value=_ref5.value;return value;}))));});});return max;}/**\n   * getYAxisProps returns the corresponding Nivo line props for supporting\n   * different Y axis types (linear and log).\n   */},{key:\"getYAxisProps\",value:function getYAxisProps(){var _this$props=this.props,statistic=_this$props.statistic,yScale=_this$props.yScale;var linearAxisLeft={// Format large y numbers as their abbreviations.\nformat:function format(y){return numeral(y).format(\"0.[0]a\");},orient:\"left\",tickSize:5,tickPadding:5,tickRotation:0,legend:statistic===\"delta\"?\"New Cases\":\"Cumulative Cases\",legendOffset:-60,legendPosition:\"middle\"};var logTickValues=[];for(var i=0;i<=Math.ceil(Math.log10(this.getDataMax()));i++){logTickValues.push(Math.pow(10,i));}// The 'axisLeft' prop for log scale is the same as for linear axis, except\n// that the tick values must be supplied.\nvar logAxisLeft=_objectSpread({},linearAxisLeft,{tickValues:logTickValues});// For log scale Y axes, we must supply the Y tick values for the grid, as\n// well as specifying the min/ max, since it seems like Nivo cannot\n// automatically determine the domain for log scale.\nif(yScale===\"log\"){return{axisLeft:logAxisLeft,gridYValues:logTickValues,yScale:{type:\"log\",base:10,min:Math.min.apply(Math,logTickValues),max:Math.max.apply(Math,logTickValues)}};}return{axisLeft:linearAxisLeft,yScale:{type:\"linear\",min:\"auto\",max:\"auto\"}};}},{key:\"render\",value:function render(){var _this3=this;var data=this.props.data;var _this$props2=this.props,statistic=_this$props2.statistic,yScale=_this$props2.yScale;// chartData contains the data that we will pass into Nivo line chart.\nvar chartData=[];// colors holds hex values for each line in the chart.\nvar colors=[];// Sort the data by area name (so we have a consistent coloring) and then\n// loop over each area.\nObject.keys(data).sort().forEach(function(area,idx){var lineColor=getLineColor(idx);var observedData=data[area].observed;// Add the observed infection data.\nchartData.push({id:area,data:_this3.processData(observedData,{statistic:statistic,yScale:yScale,initialVal:0}),// 'predicted' is a custom prop that we add so later we can tell the\n// difference between observed/predicted data when drawing the lines.\npredicted:false});colors.push(lineColor);// Add the data for each of the predicted time series. Filter out time\n// series that don't have any data associated.\ndata[area].predictions.filter(function(p){return p.time_series.length>0;}).forEach(function(p){var modelName=p.model.name;var distancing=p.distancing;var timeSeries=p.time_series;chartData.push({id:\"\".concat(area,\" (\").concat(p.model.name,\", distancing=\").concat(distancing,\")\"),// If we're displaying deltas, we pass in the last observed value as\n// the initial value for calculating the predicted deltas.\ndata:_this3.processData(timeSeries,{statistic:statistic,yScale:yScale,initialVal:observedData[observedData.length-1].value}),// 'predicted' is a custom prop that we add so later we can tell the\n// difference between observed/predicted data when drawing the lines.\npredicted:true,// 'distancing' is also a custom prop we add so we can draw the\n// line patterns differently between yes/no social distancing.\ndistancing:distancing});colors.push(lineColor);});});// Determine whether we need to show weeks or months on the X axis.\nvar tickValues=\"every week\";if(chartData.length>0){// Calculate the minimum and maximum dates present in the data.\nvar minDate=chartData[0].data[0].x;var maxDate=chartData[0].data[0].x;chartData.forEach(function(_ref6){var data=_ref6.data;data.forEach(function(_ref7){var x=_ref7.x;minDate=Math.min(minDate,x);maxDate=Math.max(maxDate,x);});});minDate=moment(minDate);maxDate=moment(maxDate);// Switch to 'every month' if the date range is over a certain threshold.\nvar diffInDays=maxDate.diff(minDate,\"days\");if(diffInDays>150){tickValues=\"every month\";}}return/*#__PURE__*/React.createElement(ResponsiveLine,Object.assign({data:chartData,colors:colors,margin:{top:50,right:50,bottom:50,left:80},xScale:{type:\"time\",format:\"native\",precision:\"day\"},axisBottom:{// tickValues determines how often / with what values our 'format'\n// func is called.\ntickValues:tickValues,// A custom 'format' func is required since all the x values are\n// javascript Date objects.\nformat:function format(date){return moment(date).format(\"M/D\");},orient:\"bottom\",tickSize:5,tickPadding:5,tickRotation:0,legend:\"Date\",legendOffset:36,legendPosition:\"middle\"}// Set up the Y axis.\n},this.getYAxisProps(),{enableSlices:\"x\",sliceTooltip:function sliceTooltip(_ref8){var slice=_ref8.slice;return/*#__PURE__*/React.createElement(\"div\",{style:{background:\"white\",padding:\"9px 12px\",border:\"1px solid #ccc\"}},/*#__PURE__*/React.createElement(\"div\",null,// Grab the date from the first point, this will be the title of\n// the tooltip.\nmoment(slice.points[0].data.x).format(\"MMM Do YYYY\")),slice.points.map(function(point){return/*#__PURE__*/React.createElement(\"div\",{key:point.id,style:{color:point.serieColor,padding:\"3px 0\"}},/*#__PURE__*/React.createElement(\"strong\",null,point.serieId),\"[\",numeral(point.data.yFormatted).format(\"0.[0]a\"),\"]\");}));},pointSize:0,pointLabel:\"y\",pointLabelYOffset:-12,legends:[{anchor:\"top-left\",direction:\"column\",justify:false,translateX:0,translateY:0,itemsSpacing:0,itemDirection:\"left-to-right\",itemWidth:80,itemHeight:20,itemOpacity:0.75,symbolSize:12,symbolShape:\"circle\",symbolBorderColor:\"rgba(0, 0, 0, .5)\",effects:[{on:\"hover\",style:{itemBackground:\"rgba(0, 0, 0, .03)\",itemOpacity:1}}]}],layers:[\"grid\",\"markers\",\"areas\",\"crosshair\",DashedLine,\"slices\",\"points\",\"axes\",\"legends\"],theme:theme}));}}]);return Covid19Graph;}(Component);export default Covid19Graph;","map":{"version":3,"sources":["/Users/tianjianxu/Documents/GitHub/ReCOVER-COVID-19/frontend/src/covid19graph.js"],"names":["React","Component","ResponsiveLine","moment","numeral","red","gold","lime","cyan","geekblue","purple","magenta","getLineColor","index","colors","primary","length","DashedLine","series","lineGenerator","xScale","yScale","map","id","data","color","predicted","distancing","style","strokeWidth","strokeDasharray","d","x","y","theme","axis","ticks","text","fontSize","legend","legends","Covid19Graph","dateStr","split","Number","year","month","day","Date","parseDate","date","value","initialVal","i","params","statistic","retData","getDeltaData","getCumulativeData","filter","props","max","Object","keys","forEach","area","observed","predictions","Math","p","timeSeries","time_series","linearAxisLeft","format","orient","tickSize","tickPadding","tickRotation","legendOffset","legendPosition","logTickValues","ceil","log10","getDataMax","push","pow","logAxisLeft","tickValues","axisLeft","gridYValues","type","base","min","chartData","sort","idx","lineColor","observedData","processData","modelName","model","name","minDate","maxDate","diffInDays","diff","top","right","bottom","left","precision","getYAxisProps","slice","background","padding","border","points","point","serieColor","serieId","yFormatted","anchor","direction","justify","translateX","translateY","itemsSpacing","itemDirection","itemWidth","itemHeight","itemOpacity","symbolSize","symbolShape","symbolBorderColor","effects","on","itemBackground"],"mappings":"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","sourcesContent":["import React, { Component } from \"react\";\nimport { ResponsiveLine } from \"@nivo/line\";\nimport moment from \"moment\";\nimport numeral from \"numeral\";\nimport {\n  red,\n  gold,\n  lime,\n  cyan,\n  geekblue,\n  purple,\n  magenta\n} from \"@ant-design/colors\";\n\nfunction getLineColor(index) {\n  const colors = [\n    red.primary,\n    gold.primary,\n    lime.primary,\n    cyan.primary,\n    geekblue.primary,\n    purple.primary,\n    magenta.primary\n  ];\n\n  return colors[index % colors.length];\n}\n\n// Custom layer for Nivo Line that allows us to display predictions as dashed\n// lines.\nconst DashedLine = ({ series, lineGenerator, xScale, yScale }) => {\n  return series.map(({ id, data, color, predicted, distancing }) => {\n    let style = {\n      strokeWidth: 3\n    };\n\n    // Add custom style if predicted.\n    if (predicted) {\n      if (distancing) {\n        style.strokeDasharray = \"6, 4\";\n      } else {\n        // Display a sparser pattern for no social distancing.\n        style.strokeDasharray = \"2, 6\";\n      }\n    }\n\n    return (\n      <path\n        key={id}\n        d={lineGenerator(\n          data.map(d => ({\n            x: xScale(d.data.x),\n            y: yScale(d.data.y)\n          }))\n        )}\n        fill=\"none\"\n        stroke={color}\n        style={style}\n      />\n    );\n  });\n};\n\nconst theme = {\n  axis: {\n    ticks: {\n      text: {\n        fontSize: 18\n      }\n    },\n    legend: {\n      text: {\n        fontSize: 18\n      }\n    }\n  },\n  legends: {\n    text: {\n      fontSize: 18\n    }\n  }\n};\n\nclass Covid19Graph extends Component {\n  parseDate(dateStr) {\n    let [year, month, day] = dateStr.split(\"-\").map(Number);\n    // Month in JS is 0-based.\n    month -= 1;\n    return new Date(year, month, day);\n  }\n\n  /**\n   * Given a time series returned by the predict endpoint, getCumulativeData\n   * returns it in Nivo format.\n   */\n  getCumulativeData(data) {\n    return data.map(d => ({\n      x: this.parseDate(d.date),\n      y: d.value\n    }));\n  }\n\n  /**\n   * Given a time series returned by the predict endpoint, getDeltaData returns\n   * the adjacent difference of the timeseries, in Nivo format.\n   * @param initialVal - The initial value that is subtracted from the 1st\n   *  element.\n   */\n  getDeltaData(data, initialVal) {\n    return data.map((d, i) => {\n      if (i === 0) {\n        return {\n          x: this.parseDate(d.date),\n          y: d.value - initialVal\n        };\n      }\n\n      return {\n        x: this.parseDate(d.date),\n        y: d.value - data[i - 1].value\n      };\n    });\n  }\n\n  // processData properly formats the given data, and performs special\n  // operations based on parameter values.\n  processData(data, params) {\n    const { statistic, yScale, initialVal } = params;\n\n    // Determine whether we need to calculate deltas between points.\n    let retData =\n      statistic === \"delta\"\n        ? this.getDeltaData(data, initialVal)\n        : this.getCumulativeData(data);\n\n    // Remove all points with y = 0 if we're using log scale, otherwise it will\n    // break.\n    if (yScale === \"log\") {\n      retData = retData.filter(({ x, y }) => y > 0);\n    }\n\n    return retData;\n  }\n\n  /**\n   * getDataMax returns the maximum value present in the data supplied to the\n   * graph.\n   */\n  getDataMax() {\n    const { data } = this.props;\n\n    let max = 0;\n\n    Object.keys(data).forEach(area => {\n      const { observed, predictions } = data[area];\n      max = Math.max(max, Math.max(...observed.map(({ value }) => value)));\n\n      predictions.forEach(p => {\n        const timeSeries = p.time_series;\n        max = Math.max(max, Math.max(...timeSeries.map(({ value }) => value)));\n      });\n    });\n\n    return max;\n  }\n\n  /**\n   * getYAxisProps returns the corresponding Nivo line props for supporting\n   * different Y axis types (linear and log).\n   */\n  getYAxisProps() {\n    const { statistic, yScale } = this.props;\n\n    const linearAxisLeft = {\n      // Format large y numbers as their abbreviations.\n      format: y => numeral(y).format(\"0.[0]a\"),\n      orient: \"left\",\n      tickSize: 5,\n      tickPadding: 5,\n      tickRotation: 0,\n      legend: statistic === \"delta\" ? \"New Cases\" : \"Cumulative Cases\",\n      legendOffset: -60,\n      legendPosition: \"middle\"\n    };\n\n    let logTickValues = [];\n    for (let i = 0; i <= Math.ceil(Math.log10(this.getDataMax())); i++) {\n      logTickValues.push(Math.pow(10, i));\n    }\n\n    // The 'axisLeft' prop for log scale is the same as for linear axis, except\n    // that the tick values must be supplied.\n    const logAxisLeft = {\n      ...linearAxisLeft,\n      tickValues: logTickValues\n    };\n\n    // For log scale Y axes, we must supply the Y tick values for the grid, as\n    // well as specifying the min/ max, since it seems like Nivo cannot\n    // automatically determine the domain for log scale.\n    if (yScale === \"log\") {\n      return {\n        axisLeft: logAxisLeft,\n        gridYValues: logTickValues,\n        yScale: {\n          type: \"log\",\n          base: 10,\n          min: Math.min(...logTickValues),\n          max: Math.max(...logTickValues)\n        }\n      };\n    }\n\n    return {\n      axisLeft: linearAxisLeft,\n      yScale: {\n        type: \"linear\",\n        min: \"auto\",\n        max: \"auto\"\n      }\n    };\n  }\n\n  render() {\n    let { data } = this.props;\n    const { statistic, yScale } = this.props;\n\n    // chartData contains the data that we will pass into Nivo line chart.\n    let chartData = [];\n    // colors holds hex values for each line in the chart.\n    let colors = [];\n\n    // Sort the data by area name (so we have a consistent coloring) and then\n    // loop over each area.\n    Object.keys(data)\n      .sort()\n      .forEach((area, idx) => {\n        const lineColor = getLineColor(idx);\n\n        const observedData = data[area].observed;\n\n        // Add the observed infection data.\n        chartData.push({\n          id: area,\n          data: this.processData(observedData, {\n            statistic: statistic,\n            yScale: yScale,\n            initialVal: 0\n          }),\n          // 'predicted' is a custom prop that we add so later we can tell the\n          // difference between observed/predicted data when drawing the lines.\n          predicted: false\n        });\n\n        colors.push(lineColor);\n\n        // Add the data for each of the predicted time series. Filter out time\n        // series that don't have any data associated.\n        data[area].predictions\n          .filter(p => p.time_series.length > 0)\n          .forEach(p => {\n            const modelName = p.model.name;\n            const distancing = p.distancing;\n            const timeSeries = p.time_series;\n\n            chartData.push({\n              id: `${area} (${p.model.name}, distancing=${distancing})`,\n              // If we're displaying deltas, we pass in the last observed value as\n              // the initial value for calculating the predicted deltas.\n              data: this.processData(timeSeries, {\n                statistic: statistic,\n                yScale: yScale,\n                initialVal: observedData[observedData.length - 1].value\n              }),\n              // 'predicted' is a custom prop that we add so later we can tell the\n              // difference between observed/predicted data when drawing the lines.\n              predicted: true,\n              // 'distancing' is also a custom prop we add so we can draw the\n              // line patterns differently between yes/no social distancing.\n              distancing: distancing\n            });\n\n            colors.push(lineColor);\n          });\n      });\n\n    // Determine whether we need to show weeks or months on the X axis.\n    let tickValues = \"every week\";\n\n    if (chartData.length > 0) {\n      // Calculate the minimum and maximum dates present in the data.\n      let minDate = chartData[0].data[0].x;\n      let maxDate = chartData[0].data[0].x;\n\n      chartData.forEach(({ data }) => {\n        data.forEach(({ x }) => {\n          minDate = Math.min(minDate, x);\n          maxDate = Math.max(maxDate, x);\n        });\n      });\n\n      minDate = moment(minDate);\n      maxDate = moment(maxDate);\n\n      // Switch to 'every month' if the date range is over a certain threshold.\n      const diffInDays = maxDate.diff(minDate, \"days\");\n      if (diffInDays > 150) {\n        tickValues = \"every month\";\n      }\n    }\n\n    return (\n      <ResponsiveLine\n        data={chartData}\n        colors={colors}\n        margin={{ top: 50, right: 50, bottom: 50, left: 80 }}\n        xScale={{\n          type: \"time\",\n          format: \"native\",\n          precision: \"day\"\n        }}\n        axisBottom={{\n          // tickValues determines how often / with what values our 'format'\n          // func is called.\n          tickValues: tickValues,\n          // A custom 'format' func is required since all the x values are\n          // javascript Date objects.\n          format: date => {\n            return moment(date).format(\"M/D\");\n          },\n          orient: \"bottom\",\n          tickSize: 5,\n          tickPadding: 5,\n          tickRotation: 0,\n          legend: \"Date\",\n          legendOffset: 36,\n          legendPosition: \"middle\"\n        }}\n        // Set up the Y axis.\n        {...this.getYAxisProps()}\n        enableSlices=\"x\"\n        sliceTooltip={({ slice }) => {\n          return (\n            <div\n              style={{\n                background: \"white\",\n                padding: \"9px 12px\",\n                border: \"1px solid #ccc\"\n              }}\n            >\n              <div>\n                {// Grab the date from the first point, this will be the title of\n                // the tooltip.\n                moment(slice.points[0].data.x).format(\"MMM Do YYYY\")}\n              </div>\n              {slice.points.map(point => (\n                <div\n                  key={point.id}\n                  style={{\n                    color: point.serieColor,\n                    padding: \"3px 0\"\n                  }}\n                >\n                  <strong>{point.serieId}</strong>[\n                  {numeral(point.data.yFormatted).format(\"0.[0]a\")}]\n                </div>\n              ))}\n            </div>\n          );\n        }}\n        pointSize={0}\n        pointLabel=\"y\"\n        pointLabelYOffset={-12}\n        legends={[\n          {\n            anchor: \"top-left\",\n            direction: \"column\",\n            justify: false,\n            translateX: 0,\n            translateY: 0,\n            itemsSpacing: 0,\n            itemDirection: \"left-to-right\",\n            itemWidth: 80,\n            itemHeight: 20,\n            itemOpacity: 0.75,\n            symbolSize: 12,\n            symbolShape: \"circle\",\n            symbolBorderColor: \"rgba(0, 0, 0, .5)\",\n            effects: [\n              {\n                on: \"hover\",\n                style: {\n                  itemBackground: \"rgba(0, 0, 0, .03)\",\n                  itemOpacity: 1\n                }\n              }\n            ]\n          }\n        ]}\n        layers={[\n          \"grid\",\n          \"markers\",\n          \"areas\",\n          \"crosshair\",\n          DashedLine,\n          \"slices\",\n          \"points\",\n          \"axes\",\n          \"legends\"\n        ]}\n        theme={theme}\n      />\n    );\n  }\n}\n\nexport default Covid19Graph;\n"]},"metadata":{},"sourceType":"module"}